// Package generator provides AST-based code generation for zero-reflection
// configuration validation.
package generator

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/mateothegreat/go-validation/internal/analyzer"
)

// CodeGenerator generates optimized validation code from analyzed configuration structs
type CodeGenerator struct {
	fileSet        *token.FileSet
	analysisResult *analyzer.AnalysisResult
	options        GeneratorOptions
}

// GeneratorOptions controls code generation behavior
type GeneratorOptions struct {
	PackageName         string
	OutputDir           string
	GenerateStrategies  bool // Generate go-config compatible strategies
	EnableOptimizations bool // Enable performance optimizations
	IncludeDebugInfo    bool // Include debug information in generated code
	FailFast            bool // Stop on first validation error
	GenerateTests       bool // Generate test code
}

// ValidationMethod represents a generated validation method
type ValidationMethod struct {
	Name       string
	StructType string
	Body       []ast.Stmt
	Optimized  bool
}

// NewCodeGenerator creates a new code generator
func NewCodeGenerator(analysisResult *analyzer.AnalysisResult, options GeneratorOptions) *CodeGenerator {
	return &CodeGenerator{
		fileSet:        token.NewFileSet(),
		analysisResult: analysisResult,
		options:        options,
	}
}

// Generate generates all validation code files
func (cg *CodeGenerator) Generate() error {
	if err := os.MkdirAll(cg.options.OutputDir, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate validation code for each struct
	for structName, structInfo := range cg.analysisResult.Structs {
		if err := cg.generateStructValidator(structName, structInfo); err != nil {
			return fmt.Errorf("failed to generate validator for %s: %w", structName, err)
		}
	}

	// Generate strategy factory if requested
	if cg.options.GenerateStrategies {
		if err := cg.generateStrategyFactory(); err != nil {
			return fmt.Errorf("failed to generate strategy factory: %w", err)
		}
	}

	return nil
}

// generateStructValidator generates a complete validator file for a struct
func (cg *CodeGenerator) generateStructValidator(structName string, structInfo *analyzer.StructInfo) error {
	filename := fmt.Sprintf("%s_validator_gen.go", strings.ToLower(structName))
	outputPath := filepath.Join(cg.options.OutputDir, filename)

	// Build AST for the generated file
	file := &ast.File{
		Name: ast.NewIdent(cg.options.PackageName),
		Decls: []ast.Decl{
			cg.generateFileHeader(),
			cg.generateImports(),
			cg.generateValidatorStruct(structName),
			cg.generateConstructor(structName),
			cg.generateValidateMethod(structName, structInfo),
		},
	}

	// Add field-specific validation methods if needed
	for _, field := range structInfo.Fields {
		if method := cg.generateFieldValidationMethod(structName, &field); method != nil {
			file.Decls = append(file.Decls, method)
		}
	}

	// Add helper methods
	file.Decls = append(file.Decls, cg.generateHelperMethods(structName)...)

	// Format and write the file
	return cg.writeFormattedFile(outputPath, file)
}

// generateFileHeader generates the file header comment
func (cg *CodeGenerator) generateFileHeader() *ast.GenDecl {
	comment := &ast.CommentGroup{
		List: []*ast.Comment{
			{Text: "// Code generated by go-validation/cmd/configvalidator. DO NOT EDIT."},
			{Text: "// This file contains zero-reflection validation code for maximum performance."},
		},
	}

	return &ast.GenDecl{
		Doc: comment,
		Tok: token.IMPORT, // This will be replaced by actual imports
	}
}

// generateImports creates the import declaration
func (cg *CodeGenerator) generateImports() *ast.GenDecl {
	var specs []ast.Spec

	for _, imp := range cg.analysisResult.Imports {
		specs = append(specs, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: fmt.Sprintf(`"%s"`, imp),
			},
		})
	}

	return &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	}
}

// generateValidatorStruct creates the validator struct declaration
func (cg *CodeGenerator) generateValidatorStruct(structName string) *ast.GenDecl {
	validatorName := structName + "Validator"

	fields := []*ast.Field{
		{
			Names: []*ast.Ident{ast.NewIdent("errors")},
			Type: &ast.ArrayType{
				Elt: &ast.SelectorExpr{
					X:   ast.NewIdent("validation"),
					Sel: ast.NewIdent("ValidationError"),
				},
			},
		},
	}

	// Add configuration options if optimizations are enabled
	if cg.options.EnableOptimizations {
		fields = append(fields, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent("failFast")},
			Type:  ast.NewIdent("bool"),
		})
	}

	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(validatorName),
				Type: &ast.StructType{
					Fields: &ast.FieldList{List: fields},
				},
			},
		},
	}
}

// generateConstructor generates a constructor function for the validator
func (cg *CodeGenerator) generateConstructor(structName string) *ast.FuncDecl {
	validatorName := structName + "Validator"
	constructorName := "New" + validatorName

	var initFields []ast.Expr

	// Initialize errors slice
	initFields = append(initFields, &ast.KeyValueExpr{
		Key: ast.NewIdent("errors"),
		Value: &ast.CallExpr{
			Fun: ast.NewIdent("make"),
			Args: []ast.Expr{
				&ast.ArrayType{
					Elt: &ast.SelectorExpr{
						X:   ast.NewIdent("validation"),
						Sel: ast.NewIdent("ValidationError"),
					},
				},
				&ast.BasicLit{Kind: token.INT, Value: "0"},
				&ast.BasicLit{Kind: token.INT, Value: "10"}, // Initial capacity
			},
		},
	})

	// Add fail fast option if optimizations are enabled
	if cg.options.EnableOptimizations {
		initFields = append(initFields, &ast.KeyValueExpr{
			Key:   ast.NewIdent("failFast"),
			Value: ast.NewIdent("false"),
		})
	}

	return &ast.FuncDecl{
		Name: ast.NewIdent(constructorName),
		Type: &ast.FuncType{
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: ast.NewIdent(validatorName),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: ast.NewIdent(validatorName),
								Elts: initFields,
							},
						},
					},
				},
			},
		},
	}
}

// generateValidateMethod creates the main Validate method
func (cg *CodeGenerator) generateValidateMethod(structName string, structInfo *analyzer.StructInfo) *ast.FuncDecl {
	validatorName := structName + "Validator"
	var stmts []ast.Stmt

	// Reset errors at the beginning
	stmts = append(stmts, &ast.AssignStmt{
		Lhs: []ast.Expr{
			&ast.SelectorExpr{
				X:   ast.NewIdent("v"),
				Sel: ast.NewIdent("errors"),
			},
		},
		Tok: token.ASSIGN,
		Rhs: []ast.Expr{
			&ast.SelectorExpr{
				X:   ast.NewIdent("v"),
				Sel: ast.NewIdent("errors"),
			},
			&ast.SliceExpr{
				X:    &ast.SelectorExpr{X: ast.NewIdent("v"), Sel: ast.NewIdent("errors")},
				Low:  &ast.BasicLit{Kind: token.INT, Value: "0"},
				High: &ast.BasicLit{Kind: token.INT, Value: "0"},
			},
		},
	})

	// Generate validation calls for each field
	for _, field := range structInfo.Fields {
		fieldStmts := cg.generateFieldValidation(structName, &field)
		stmts = append(stmts, fieldStmts...)
	}

	// Return error if any validation failed
	stmts = append(stmts, &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun: ast.NewIdent("len"),
				Args: []ast.Expr{
					&ast.SelectorExpr{
						X:   ast.NewIdent("v"),
						Sel: ast.NewIdent("errors"),
					},
				},
			},
			Op: token.GTR,
			Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("validation"),
								Sel: ast.NewIdent("ValidationErrors"),
							},
							Args: []ast.Expr{
								&ast.SelectorExpr{
									X:   ast.NewIdent("v"),
									Sel: ast.NewIdent("errors"),
								},
							},
						},
					},
				},
			},
		},
	})

	stmts = append(stmts, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("nil")},
	})

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("v")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(validatorName),
					},
				},
			},
		},
		Name: ast.NewIdent("Validate"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("cfg")},
						Type: &ast.StarExpr{
							X: ast.NewIdent(structName),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{List: stmts},
	}
}

// generateFieldValidation generates validation code for a single field
func (cg *CodeGenerator) generateFieldValidation(structName string, field *analyzer.FieldInfo) []ast.Stmt {
	var stmts []ast.Stmt

	fieldAccess := &ast.SelectorExpr{
		X:   ast.NewIdent("cfg"),
		Sel: ast.NewIdent(field.Name),
	}

	// Handle pointer fields with nil checking
	if field.GoType.IsPointer {
		stmts = append(stmts, cg.generatePointerNilCheck(field, fieldAccess)...)
		fieldAccess = &ast.SelectorExpr{X: fieldAccess, Sel: ast.NewIdent("*")}
	}

	// Generate validation for each rule
	for _, rule := range field.ValidationRules {
		ruleStmts := cg.generateRuleValidation(field, rule, fieldAccess)
		stmts = append(stmts, ruleStmts...)

		// Add fail-fast check if optimizations are enabled
		if cg.options.EnableOptimizations && cg.options.FailFast {
			stmts = append(stmts, cg.generateFailFastCheck()...)
		}
	}

	// Handle nested struct validation
	if field.IsNested {
		stmts = append(stmts, cg.generateNestedValidation(field, fieldAccess)...)
	}

	return stmts
}

// generatePointerNilCheck generates nil checking code for pointer fields
func (cg *CodeGenerator) generatePointerNilCheck(field *analyzer.FieldInfo, fieldAccess ast.Expr) []ast.Stmt {
	var stmts []ast.Stmt

	// Check if field is required
	isRequired := false
	for _, rule := range field.ValidationRules {
		if rule.Name == "required" {
			isRequired = true
			break
		}
	}

	if isRequired {
		// Add nil check for required fields
		stmts = append(stmts, &ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X:  fieldAccess,
				Op: token.EQL,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					cg.generateAddError(field.Name, "required", "", "field is required but is nil"),
				},
			},
		})
	} else {
		// Skip validation if field is nil and not required
		stmts = append(stmts, &ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X:  fieldAccess,
				Op: token.EQL,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{}, // Early return for nil optional fields
				},
			},
		})
	}

	return stmts
}

// generateRuleValidation generates validation code for a specific rule
func (cg *CodeGenerator) generateRuleValidation(field *analyzer.FieldInfo, rule analyzer.ValidationRule, fieldAccess ast.Expr) []ast.Stmt {
	switch rule.Name {
	case "required":
		return cg.generateRequiredValidation(field, fieldAccess)
	case "min":
		return cg.generateMinValidation(field, rule, fieldAccess)
	case "max":
		return cg.generateMaxValidation(field, rule, fieldAccess)
	case "len":
		return cg.generateLenValidation(field, rule, fieldAccess)
	case "email":
		return cg.generateEmailValidation(field, fieldAccess)
	case "url", "uri":
		return cg.generateURLValidation(field, fieldAccess)
	case "ip":
		return cg.generateIPValidation(field, fieldAccess)
	case "oneof":
		return cg.generateOneOfValidation(field, rule, fieldAccess)
	case "alpha":
		return cg.generateAlphaValidation(field, fieldAccess)
	case "numeric":
		return cg.generateNumericValidation(field, fieldAccess)
	default:
		// Use reflection-based validation as fallback
		return cg.generateGenericValidation(field, rule, fieldAccess)
	}
}

// generateRequiredValidation generates optimized required field validation
func (cg *CodeGenerator) generateRequiredValidation(field *analyzer.FieldInfo, fieldAccess ast.Expr) []ast.Stmt {
	var condition ast.Expr

	switch field.GoType.Kind {
	case analyzer.TypeString:
		condition = &ast.BinaryExpr{
			X:  fieldAccess,
			Op: token.EQL,
			Y:  &ast.BasicLit{Kind: token.STRING, Value: `""`},
		}
	case analyzer.TypeInt, analyzer.TypeInt8, analyzer.TypeInt16, analyzer.TypeInt32, analyzer.TypeInt64:
		condition = &ast.BinaryExpr{
			X:  fieldAccess,
			Op: token.EQL,
			Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
		}
	case analyzer.TypeSlice:
		condition = &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{fieldAccess},
			},
			Op: token.EQL,
			Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
		}
	default:
		// Use generic zero-value check
		condition = &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("reflect"),
				Sel: ast.NewIdent("DeepEqual"),
			},
			Args: []ast.Expr{
				fieldAccess,
				&ast.CallExpr{
					Fun: ast.NewIdent("new"),
					Args: []ast.Expr{
						&ast.ParenExpr{
							X: &ast.StarExpr{
								X: &ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X:   ast.NewIdent("reflect"),
										Sel: ast.NewIdent("TypeOf"),
									},
									Args: []ast.Expr{fieldAccess},
								},
							},
						},
					},
				},
			},
		}
	}

	return []ast.Stmt{
		&ast.IfStmt{
			Cond: condition,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					cg.generateAddError(field.Name, "required", "", "field is required"),
				},
			},
		},
	}
}

// generateMinValidation generates optimized minimum value/length validation
func (cg *CodeGenerator) generateMinValidation(field *analyzer.FieldInfo, rule analyzer.ValidationRule, fieldAccess ast.Expr) []ast.Stmt {
	// Try parsing as integer first
	minVal, intErr := strconv.ParseInt(rule.Parameter, 10, 64)
	// Try parsing as float if integer parsing fails
	_, floatErr := strconv.ParseFloat(rule.Parameter, 64)
	
	if intErr != nil && floatErr != nil {
		return cg.generateGenericValidation(field, rule, fieldAccess)
	}

	var condition ast.Expr
	var errorMessage string

	switch field.GoType.Kind {
	case analyzer.TypeString:
		if intErr != nil {
			return cg.generateGenericValidation(field, rule, fieldAccess)
		}
		condition = &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{fieldAccess},
			},
			Op: token.LSS,
			Y:  &ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(minVal, 10)},
		}
		errorMessage = fmt.Sprintf("value must be at least %d characters", minVal)
	case analyzer.TypeInt, analyzer.TypeInt8, analyzer.TypeInt16, analyzer.TypeInt32, analyzer.TypeInt64:
		if intErr != nil {
			return cg.generateGenericValidation(field, rule, fieldAccess)
		}
		condition = &ast.BinaryExpr{
			X:  fieldAccess,
			Op: token.LSS,
			Y:  &ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(minVal, 10)},
		}
		errorMessage = fmt.Sprintf("value must be at least %d", minVal)
	case analyzer.TypeFloat32, analyzer.TypeFloat64:
		// For float types, use float comparison
		if floatErr != nil {
			return cg.generateGenericValidation(field, rule, fieldAccess)
		}
		condition = &ast.BinaryExpr{
			X:  fieldAccess,
			Op: token.LSS,
			Y:  &ast.BasicLit{Kind: token.FLOAT, Value: rule.Parameter},
		}
		errorMessage = fmt.Sprintf("value must be at least %s", rule.Parameter)
	case analyzer.TypeSlice:
		if intErr != nil {
			return cg.generateGenericValidation(field, rule, fieldAccess)
		}
		condition = &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{fieldAccess},
			},
			Op: token.LSS,
			Y:  &ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(minVal, 10)},
		}
		errorMessage = fmt.Sprintf("must have at least %d items", minVal)
	default:
		return cg.generateGenericValidation(field, rule, fieldAccess)
	}

	return []ast.Stmt{
		&ast.IfStmt{
			Cond: condition,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					cg.generateAddError(field.Name, "min", rule.Parameter, errorMessage),
				},
			},
		},
	}
}

// generateMaxValidation generates optimized maximum value/length validation
func (cg *CodeGenerator) generateMaxValidation(field *analyzer.FieldInfo, rule analyzer.ValidationRule, fieldAccess ast.Expr) []ast.Stmt {
	// Try parsing as integer first
	maxVal, intErr := strconv.ParseInt(rule.Parameter, 10, 64)
	// Try parsing as float if integer parsing fails
	_, floatErr := strconv.ParseFloat(rule.Parameter, 64)
	
	if intErr != nil && floatErr != nil {
		return cg.generateGenericValidation(field, rule, fieldAccess)
	}

	var condition ast.Expr
	var errorMessage string

	switch field.GoType.Kind {
	case analyzer.TypeString:
		if intErr != nil {
			return cg.generateGenericValidation(field, rule, fieldAccess)
		}
		condition = &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{fieldAccess},
			},
			Op: token.GTR,
			Y:  &ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(maxVal, 10)},
		}
		errorMessage = fmt.Sprintf("value must be at most %d characters", maxVal)
	case analyzer.TypeInt, analyzer.TypeInt8, analyzer.TypeInt16, analyzer.TypeInt32, analyzer.TypeInt64:
		if intErr != nil {
			return cg.generateGenericValidation(field, rule, fieldAccess)
		}
		condition = &ast.BinaryExpr{
			X:  fieldAccess,
			Op: token.GTR,
			Y:  &ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(maxVal, 10)},
		}
		errorMessage = fmt.Sprintf("value must be at most %d", maxVal)
	case analyzer.TypeFloat32, analyzer.TypeFloat64:
		// For float types, use float comparison
		if floatErr != nil {
			return cg.generateGenericValidation(field, rule, fieldAccess)
		}
		condition = &ast.BinaryExpr{
			X:  fieldAccess,
			Op: token.GTR,
			Y:  &ast.BasicLit{Kind: token.FLOAT, Value: rule.Parameter},
		}
		errorMessage = fmt.Sprintf("value must be at most %s", rule.Parameter)
	case analyzer.TypeSlice:
		if intErr != nil {
			return cg.generateGenericValidation(field, rule, fieldAccess)
		}
		condition = &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{fieldAccess},
			},
			Op: token.GTR,
			Y:  &ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(maxVal, 10)},
		}
		errorMessage = fmt.Sprintf("must have at most %d items", maxVal)
	default:
		return cg.generateGenericValidation(field, rule, fieldAccess)
	}

	return []ast.Stmt{
		&ast.IfStmt{
			Cond: condition,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					cg.generateAddError(field.Name, "max", rule.Parameter, errorMessage),
				},
			},
		},
	}
}

// generateLenValidation generates exact length validation
func (cg *CodeGenerator) generateLenValidation(field *analyzer.FieldInfo, rule analyzer.ValidationRule, fieldAccess ast.Expr) []ast.Stmt {
	lenVal, err := strconv.ParseInt(rule.Parameter, 10, 64)
	if err != nil {
		return cg.generateGenericValidation(field, rule, fieldAccess)
	}

	var condition ast.Expr

	switch field.GoType.Kind {
	case analyzer.TypeString, analyzer.TypeSlice:
		condition = &ast.BinaryExpr{
			X: &ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{fieldAccess},
			},
			Op: token.NEQ,
			Y:  &ast.BasicLit{Kind: token.INT, Value: strconv.FormatInt(lenVal, 10)},
		}
	default:
		return cg.generateGenericValidation(field, rule, fieldAccess)
	}

	return []ast.Stmt{
		&ast.IfStmt{
			Cond: condition,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					cg.generateAddError(field.Name, "len", rule.Parameter,
						fmt.Sprintf("value must be exactly %d characters/elements", lenVal)),
				},
			},
		},
	}
}

// generateEmailValidation generates email validation using existing validator
func (cg *CodeGenerator) generateEmailValidation(field *analyzer.FieldInfo, fieldAccess ast.Expr) []ast.Stmt {
	return []ast.Stmt{
		&ast.IfStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("err")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("validation"),
							Sel: ast.NewIdent("ValidateEmail"),
						},
						Args: []ast.Expr{
							&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, field.Name)},
							fieldAccess,
						},
					},
				},
			},
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("v"),
								Sel: ast.NewIdent("addValidationError"),
							},
							Args: []ast.Expr{ast.NewIdent("err")},
						},
					},
				},
			},
		},
	}
}

// generateURLValidation generates URL validation using existing validator
func (cg *CodeGenerator) generateURLValidation(field *analyzer.FieldInfo, fieldAccess ast.Expr) []ast.Stmt {
	return []ast.Stmt{
		&ast.IfStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("err")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("validation"),
							Sel: ast.NewIdent("ValidateURL"),
						},
						Args: []ast.Expr{
							&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, field.Name)},
							fieldAccess,
						},
					},
				},
			},
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("v"),
								Sel: ast.NewIdent("addValidationError"),
							},
							Args: []ast.Expr{ast.NewIdent("err")},
						},
					},
				},
			},
		},
	}
}

// generateIPValidation generates IP validation using existing validator
func (cg *CodeGenerator) generateIPValidation(field *analyzer.FieldInfo, fieldAccess ast.Expr) []ast.Stmt {
	return []ast.Stmt{
		&ast.IfStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("err")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("validation"),
							Sel: ast.NewIdent("ValidateIP"),
						},
						Args: []ast.Expr{
							&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, field.Name)},
							fieldAccess,
						},
					},
				},
			},
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("v"),
								Sel: ast.NewIdent("addValidationError"),
							},
							Args: []ast.Expr{ast.NewIdent("err")},
						},
					},
				},
			},
		},
	}
}

// generateOneOfValidation generates optimized oneof validation
func (cg *CodeGenerator) generateOneOfValidation(field *analyzer.FieldInfo, rule analyzer.ValidationRule, fieldAccess ast.Expr) []ast.Stmt {
	values := strings.Fields(rule.Parameter)
	if len(values) == 0 {
		return nil
	}

	// Build condition: value != val1 && value != val2 && ...
	var condition ast.Expr
	for _, val := range values {
		notEqual := &ast.BinaryExpr{
			X:  fieldAccess,
			Op: token.NEQ,
			Y:  &ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, val)},
		}

		if condition == nil {
			condition = notEqual
		} else {
			condition = &ast.BinaryExpr{
				X:  condition,
				Op: token.LAND,
				Y:  notEqual,
			}
		}
	}

	return []ast.Stmt{
		&ast.IfStmt{
			Cond: condition,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					cg.generateAddError(field.Name, "oneof", rule.Parameter,
						fmt.Sprintf("value must be one of: %s", strings.Join(values, ", "))),
				},
			},
		},
	}
}

// generateAlphaValidation generates optimized alphabetic character validation
func (cg *CodeGenerator) generateAlphaValidation(field *analyzer.FieldInfo, fieldAccess ast.Expr) []ast.Stmt {
	return []ast.Stmt{
		&ast.RangeStmt{
			Key:   ast.NewIdent("_"),
			Value: ast.NewIdent("r"),
			Tok:   token.DEFINE,
			X:     fieldAccess,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.IfStmt{
						Cond: &ast.UnaryExpr{
							Op: token.NOT,
							X: &ast.ParenExpr{
								X: &ast.BinaryExpr{
									X: &ast.ParenExpr{
										X: &ast.BinaryExpr{
											X:  ast.NewIdent("r"),
											Op: token.GEQ,
											Y:  &ast.BasicLit{Kind: token.CHAR, Value: "'a'"},
										},
									},
									Op: token.LAND,
									Y: &ast.ParenExpr{
										X: &ast.BinaryExpr{
											X:  ast.NewIdent("r"),
											Op: token.LEQ,
											Y:  &ast.BasicLit{Kind: token.CHAR, Value: "'z'"},
										},
									},
								},
							},
						},
						Body: &ast.BlockStmt{
							List: []ast.Stmt{
								&ast.IfStmt{
									Cond: &ast.UnaryExpr{
										Op: token.NOT,
										X: &ast.ParenExpr{
											X: &ast.BinaryExpr{
												X: &ast.ParenExpr{
													X: &ast.BinaryExpr{
														X:  ast.NewIdent("r"),
														Op: token.GEQ,
														Y:  &ast.BasicLit{Kind: token.CHAR, Value: "'A'"},
													},
												},
												Op: token.LAND,
												Y: &ast.ParenExpr{
													X: &ast.BinaryExpr{
														X:  ast.NewIdent("r"),
														Op: token.LEQ,
														Y:  &ast.BasicLit{Kind: token.CHAR, Value: "'Z'"},
													},
												},
											},
										},
									},
									Body: &ast.BlockStmt{
										List: []ast.Stmt{
											cg.generateAddError(field.Name, "alpha", "", "field must contain only alphabetic characters"),
											&ast.BranchStmt{Tok: token.BREAK},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateNumericValidation generates optimized numeric character validation
func (cg *CodeGenerator) generateNumericValidation(field *analyzer.FieldInfo, fieldAccess ast.Expr) []ast.Stmt {
	return []ast.Stmt{
		&ast.RangeStmt{
			Key:   ast.NewIdent("_"),
			Value: ast.NewIdent("r"),
			Tok:   token.DEFINE,
			X:     fieldAccess,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.IfStmt{
						Cond: &ast.BinaryExpr{
							X: &ast.ParenExpr{
								X: &ast.BinaryExpr{
									X:  ast.NewIdent("r"),
									Op: token.LSS,
									Y:  &ast.BasicLit{Kind: token.CHAR, Value: "'0'"},
								},
							},
							Op: token.LOR,
							Y: &ast.ParenExpr{
								X: &ast.BinaryExpr{
									X:  ast.NewIdent("r"),
									Op: token.GTR,
									Y:  &ast.BasicLit{Kind: token.CHAR, Value: "'9'"},
								},
							},
						},
						Body: &ast.BlockStmt{
							List: []ast.Stmt{
								cg.generateAddError(field.Name, "numeric", "", "field must contain only numeric characters"),
								&ast.BranchStmt{Tok: token.BREAK},
							},
						},
					},
				},
			},
		},
	}
}

// generateGenericValidation generates fallback validation using the validation library
func (cg *CodeGenerator) generateGenericValidation(field *analyzer.FieldInfo, rule analyzer.ValidationRule, fieldAccess ast.Expr) []ast.Stmt {
	// Construct validation tag
	var tag string
	if rule.Parameter != "" {
		tag = rule.Name + "=" + rule.Parameter
	} else {
		tag = rule.Name
	}

	return []ast.Stmt{
		&ast.IfStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("err")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("validation"),
							Sel: ast.NewIdent("Var"),
						},
						Args: []ast.Expr{
							fieldAccess,
							&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, tag)},
						},
					},
				},
			},
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("err"),
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("v"),
								Sel: ast.NewIdent("addValidationError"),
							},
							Args: []ast.Expr{ast.NewIdent("err")},
						},
					},
				},
			},
		},
	}
}

// generateNestedValidation generates validation for nested structs
func (cg *CodeGenerator) generateNestedValidation(field *analyzer.FieldInfo, fieldAccess ast.Expr) []ast.Stmt {
	validatorName := field.NestedType + "Validator"

	return []ast.Stmt{
		&ast.IfStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("nestedValidator")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: ast.NewIdent("New" + validatorName),
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.IfStmt{
						Init: &ast.AssignStmt{
							Lhs: []ast.Expr{ast.NewIdent("err")},
							Tok: token.DEFINE,
							Rhs: []ast.Expr{
								&ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X:   ast.NewIdent("nestedValidator"),
										Sel: ast.NewIdent("Validate"),
									},
									Args: []ast.Expr{fieldAccess},
								},
							},
						},
						Cond: &ast.BinaryExpr{
							X:  ast.NewIdent("err"),
							Op: token.NEQ,
							Y:  ast.NewIdent("nil"),
						},
						Body: &ast.BlockStmt{
							List: []ast.Stmt{
								&ast.ExprStmt{
									X: &ast.CallExpr{
										Fun: &ast.SelectorExpr{
											X:   ast.NewIdent("v"),
											Sel: ast.NewIdent("addNestedErrors"),
										},
										Args: []ast.Expr{
											&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, field.Name)},
											ast.NewIdent("err"),
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateFailFastCheck generates fail-fast optimization code
func (cg *CodeGenerator) generateFailFastCheck() []ast.Stmt {
	return []ast.Stmt{
		&ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X: &ast.SelectorExpr{
					X:   ast.NewIdent("v"),
					Sel: ast.NewIdent("failFast"),
				},
				Op: token.LAND,
				Y: &ast.BinaryExpr{
					X: &ast.CallExpr{
						Fun: ast.NewIdent("len"),
						Args: []ast.Expr{
							&ast.SelectorExpr{
								X:   ast.NewIdent("v"),
								Sel: ast.NewIdent("errors"),
							},
						},
					},
					Op: token.GTR,
					Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent("validation"),
									Sel: ast.NewIdent("ValidationErrors"),
								},
								Args: []ast.Expr{
									&ast.SelectorExpr{
										X:   ast.NewIdent("v"),
										Sel: ast.NewIdent("errors"),
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateAddError generates code to add a validation error
func (cg *CodeGenerator) generateAddError(fieldName, tag, param, message string) ast.Stmt {
	return &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("v"),
				Sel: ast.NewIdent("addError"),
			},
			Args: []ast.Expr{
				&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, fieldName)},
				&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, tag)},
				&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, param)},
				&ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, message)},
			},
		},
	}
}

// generateFieldValidationMethod generates a field-specific validation method if beneficial
func (cg *CodeGenerator) generateFieldValidationMethod(structName string, field *analyzer.FieldInfo) *ast.FuncDecl {
	// Only generate separate methods for complex fields with multiple rules
	if len(field.ValidationRules) < 3 && !field.IsNested {
		return nil
	}

	validatorName := structName + "Validator"
	methodName := fmt.Sprintf("validate%s", field.Name)

	var stmts []ast.Stmt
	fieldAccess := ast.NewIdent("value")

	// Generate validation for each rule
	for _, rule := range field.ValidationRules {
		ruleStmts := cg.generateRuleValidation(field, rule, fieldAccess)
		stmts = append(stmts, ruleStmts...)
	}

	stmts = append(stmts, &ast.ReturnStmt{
		Results: []ast.Expr{ast.NewIdent("nil")},
	})

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("v")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(validatorName),
					},
				},
			},
		},
		Name: ast.NewIdent(methodName),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("value")},
						Type:  ast.NewIdent(field.Type),
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{List: stmts},
	}
}

// generateHelperMethods generates helper methods for the validator
func (cg *CodeGenerator) generateHelperMethods(structName string) []ast.Decl {
	validatorName := structName + "Validator"
	var decls []ast.Decl

	// addError helper method
	decls = append(decls, &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("v")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(validatorName),
					},
				},
			},
		},
		Name: ast.NewIdent("addError"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{Names: []*ast.Ident{ast.NewIdent("field")}, Type: ast.NewIdent("string")},
					{Names: []*ast.Ident{ast.NewIdent("tag")}, Type: ast.NewIdent("string")},
					{Names: []*ast.Ident{ast.NewIdent("param")}, Type: ast.NewIdent("string")},
					{Names: []*ast.Ident{ast.NewIdent("message")}, Type: ast.NewIdent("string")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.SelectorExpr{
							X:   ast.NewIdent("v"),
							Sel: ast.NewIdent("errors"),
						},
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: ast.NewIdent("append"),
							Args: []ast.Expr{
								&ast.SelectorExpr{
									X:   ast.NewIdent("v"),
									Sel: ast.NewIdent("errors"),
								},
								&ast.CompositeLit{
									Type: &ast.SelectorExpr{
										X:   ast.NewIdent("validation"),
										Sel: ast.NewIdent("ValidationError"),
									},
									Elts: []ast.Expr{
										&ast.KeyValueExpr{
											Key:   ast.NewIdent("Field"),
											Value: ast.NewIdent("field"),
										},
										&ast.KeyValueExpr{
											Key:   ast.NewIdent("Tag"),
											Value: ast.NewIdent("tag"),
										},
										&ast.KeyValueExpr{
											Key:   ast.NewIdent("Param"),
											Value: ast.NewIdent("param"),
										},
										&ast.KeyValueExpr{
											Key:   ast.NewIdent("Message"),
											Value: ast.NewIdent("message"),
										},
									},
								},
							},
						},
					},
				},
			},
		},
	})

	// addValidationError helper method
	decls = append(decls, &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("v")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(validatorName),
					},
				},
			},
		},
		Name: ast.NewIdent("addValidationError"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{Names: []*ast.Ident{ast.NewIdent("err")}, Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.IfStmt{
					Init: &ast.AssignStmt{
						Lhs: []ast.Expr{ast.NewIdent("valErr"), ast.NewIdent("ok")},
						Tok: token.DEFINE,
						Rhs: []ast.Expr{
							&ast.TypeAssertExpr{
								X:    ast.NewIdent("err"),
								Type: &ast.SelectorExpr{X: ast.NewIdent("validation"), Sel: ast.NewIdent("ValidationError")},
							},
						},
					},
					Cond: ast.NewIdent("ok"),
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.AssignStmt{
								Lhs: []ast.Expr{
									&ast.SelectorExpr{
										X:   ast.NewIdent("v"),
										Sel: ast.NewIdent("errors"),
									},
								},
								Tok: token.ASSIGN,
								Rhs: []ast.Expr{
									&ast.CallExpr{
										Fun: ast.NewIdent("append"),
										Args: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("v"),
												Sel: ast.NewIdent("errors"),
											},
											ast.NewIdent("valErr"),
										},
									},
								},
							},
						},
					},
				},
			},
		},
	})

	return decls
}

// generateStrategyFactory generates go-config compatible strategy factory
func (cg *CodeGenerator) generateStrategyFactory() error {
	filename := "validation_strategy_gen.go"
	outputPath := filepath.Join(cg.options.OutputDir, filename)

	// Build AST for strategy factory
	file := &ast.File{
		Name: ast.NewIdent(cg.options.PackageName),
		Decls: []ast.Decl{
			cg.generateFileHeader(),
			cg.generateStrategyImports(),
			cg.generateStrategyInterface(),
			cg.generateStrategyImpl(),
			cg.generateStrategyConstructor(),
		},
	}

	return cg.writeFormattedFile(outputPath, file)
}

// generateStrategyImports generates imports for strategy file
func (cg *CodeGenerator) generateStrategyImports() *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{
			&ast.ImportSpec{
				Path: &ast.BasicLit{Kind: token.STRING, Value: `"context"`},
			},
			&ast.ImportSpec{
				Path: &ast.BasicLit{Kind: token.STRING, Value: `"fmt"`},
			},
		},
	}
}

// generateStrategyInterface generates the validation strategy interface
func (cg *CodeGenerator) generateStrategyInterface() *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent("ValidationStrategy"),
				Type: &ast.InterfaceType{
					Methods: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("Validate")},
								Type: &ast.FuncType{
									Params: &ast.FieldList{
										List: []*ast.Field{
											{Names: []*ast.Ident{ast.NewIdent("ctx")}, Type: &ast.SelectorExpr{X: ast.NewIdent("context"), Sel: ast.NewIdent("Context")}},
											{Names: []*ast.Ident{ast.NewIdent("config")}, Type: ast.NewIdent("interface{}")},
										},
									},
									Results: &ast.FieldList{
										List: []*ast.Field{
											{Type: ast.NewIdent("error")},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateStrategyImpl generates the strategy implementation
func (cg *CodeGenerator) generateStrategyImpl() *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent("GeneratedValidationStrategy"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{ast.NewIdent("validators")},
								Type: &ast.MapType{
									Key: ast.NewIdent("string"),
									Value: &ast.InterfaceType{
										Methods: &ast.FieldList{
											List: []*ast.Field{
												{
													Names: []*ast.Ident{ast.NewIdent("Validate")},
													Type: &ast.FuncType{
														Params: &ast.FieldList{
															List: []*ast.Field{
																{Type: ast.NewIdent("interface{}")},
															},
														},
														Results: &ast.FieldList{
															List: []*ast.Field{
																{Type: ast.NewIdent("error")},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// generateStrategyConstructor generates the strategy constructor
func (cg *CodeGenerator) generateStrategyConstructor() *ast.FuncDecl {
	var initElements []ast.Expr

	// Add validator for each struct
	for structName := range cg.analysisResult.Structs {
		initElements = append(initElements, &ast.KeyValueExpr{
			Key: &ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, structName)},
			Value: &ast.CallExpr{
				Fun: ast.NewIdent("New" + structName + "Validator"),
			},
		})
	}

	return &ast.FuncDecl{
		Name: ast.NewIdent("NewGeneratedValidationStrategy"),
		Type: &ast.FuncType{
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("ValidationStrategy")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: ast.NewIdent("GeneratedValidationStrategy"),
								Elts: []ast.Expr{
									&ast.KeyValueExpr{
										Key: ast.NewIdent("validators"),
										Value: &ast.CompositeLit{
											Type: &ast.MapType{
												Key: ast.NewIdent("string"),
												Value: &ast.InterfaceType{
													Methods: &ast.FieldList{},
												},
											},
											Elts: initElements,
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// writeFormattedFile writes an AST file with proper formatting
func (cg *CodeGenerator) writeFormattedFile(filename string, file *ast.File) error {
	f, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filename, err)
	}
	defer f.Close()

	// Write generation comment
	f.WriteString("// Code generated by go-validation/cmd/configvalidator. DO NOT EDIT.\n\n")

	// Format and write the AST
	if err := format.Node(f, cg.fileSet, file); err != nil {
		return fmt.Errorf("failed to format file %s: %w", filename, err)
	}

	return nil
}
